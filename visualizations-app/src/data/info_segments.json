{
  "Intro": [
    {
      "type": "info",
      "title": "Why Algorithms?",
      "text": "What is an Algorithm?<ul><br/> <li> An algorithm is a set of instructions designed to perform a specific task.</li><br/> <li> A step-by-step solution, like a recipe </li> </ul>",
      "image_link": "/assets/why-algorithms/why-alg-1.gif"
    },
    {
      "type": "info",
      "title": "Why Algorithms?",
      "text": "How are computers better than humans?<ul><br/><li>Better memories</li><br/><li>Significantly faster and more accurate at executing tasks</li><br/><li>Not influenced by human factors such as emotion, exhaustion, etc</li></ul>",
      "image_link": "/assets/why-algorithms/Human-Computer.jpg"
    },
    {
      "type": "info",
      "title": "Why Algorithms?",
      "text": "Why Learn About Algorithms?<ul><br/><li>Algorithms make it possible to solve everyday tasks such as</li><ul><li>Booking a flight</li><li>Adding a mutual friend on Facebook</li><li>Finding the fastest route to a new destination</li><li>Getting new movie recommendations based on what you’ve watched</li></ul><br><li>They are the future!</li></ul>",
      "image_link": "/assets/why-algorithms/types-of-algorithm.png"
    },
    {
      "type": "info",
      "title": "Why Algorithms?",
      "text": "How do we harness the powers of  computers?<ul><li>By writing algorithms!</li><li>Computers are very effective at solving well defined problems.</li><ul><li>It is up to the programmer to implement the step-by-step solution to solve some problem.</li> <li>Once the solution is written and is correct, the computer will have no issues executing that exact algorithm for its entire lifetime</li></ul></ul>",
      "image_link": "/assets/why-algorithms/harness-computers.gif"
    },
    {
      "type": "info",
      "title": "Why Algorithms?",
      "text":"Algorithms form the basis of some of the most important aspects of daily life. From powering GPS navigation apps, search engines, computer operating systems, social media news feeds, internet routing networks, recommendation systems, self-driving cars, and more - algorithms are all around us!<br><br>We believe that basic knowledge of data structures and algorithms provide the fundamental foundation for facilitating critical problem-solving skills and computational thinking.",
      "image_link": "/assets/why-algorithms/dijkstra.gif"
    },
    {
      "type": "info",
      "title": "Why Algorithms?",
      "text":"Want to learn about fundamental algorithms?<br/><br/> <b>↓ EMBARK ON THE LEARNER QUEST ↓</b> <br><br>",
      "image_link": "/assets/why-algorithms/learning-more.gif"
    }
  ],
  "Stack": [
    {
      "type": "info",
      "title": "Stack",
      "text": "A stack is an abstract data structure often used throughout many algorithms in computer science. A stack is exactly just that: a stack of objects like we see in everyday life. Like a stack of plates on a table, you can only take off the top object (<i>pop</i>), or place a new object on top (<i>push</i>).  Let’s take a look at some of the key characteristics...",
      "image_link": "/assets/stack/book-stack.png"
    },
    {
      "type": "info",
      "title": "Characteristics of a Stack",
      "text": "<ul><li><b>Last In, First Out</b> (<b>LIFO</b>): The last object added to the stack will be on top of the rest, and therefore will be taken off the stack first.</li><li><b>Push</b>(<i>object</i>) adds an object on top of the stack</li><li><b>Pop</b>() will remove the top element from the stack</li></ul>",
      "image_link": "/assets/need-img.png"
    },
    {
      "type": "info",
      "title": "More on Stacks",
      "text":"There are some very useful features of stacks that are able to make certain problems much easier to solve. That being said, let’s consider some things when using stacks:<ul><li>Removing an element from the middle of a stack is not possible</li><li>Adding too many objects (stack overflow) or removing objects that are not present (stack underflow) will break your code.</li><li>Avoid implementing your own stack class. Instead, import from the necessary library. It will save you time and unnecessary confusion</li></ul>",
      "image_link": "/assets/stack/stack-pop.png"
    },

    {
      "type": "quiz",
      "title": "Question #1",
      "text": "A stack can be best described as a ____ data structure.",
      "options": ["Push Out, Pop In", "First In, First Out", "Pull In, Push Out", "Last In, First Out"],
      "answer": "Last In, First Out",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #2",
      "text": "If you wanted to add an object to the stack, you would use this operation",
      "options": ["pop()", "push(object)", "add(object)", "append(object)"],
      "answer": "push(object)",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #3",
      "text": "If too many items are pushed into the stack, this results in a",
      "options": ["stack error", "stack underflow", "stack overflow", "stack influx" ],
      "answer": "stack overflow",
      "image_link": "/assets/question-mark.gif"
    }
  ],
  "Queue": [
    {
      "type": "info",
      "title": "Queue",
      "text": "A queue is a data structure often used throughout many algorithms in computer science. A queue behaves very much in the same way that a stack does. It is like an array in that you put many objects into an array for later use. Also like a stack, you can’t remove elements in the middle of a queue. Think of a queue like a line at the grocery store. In fact, that’s exactly what a line is, a queue! Knowing what you know now about stacks, learning about queues should be no problem at all.",
      "image_link": "/assets/queue/line-of-people.jpg"
    },
    {
      "type": "info",
      "title": "Characteristics of a Queue",
      "text":"<ul><li>An array of fixed size</li><li>First-In-First-Out (FIFO). Whichever element is put in first, it is the first element out. This is the main behavioral difference between a stack and queue</li><li>Enqueue(item) will add an element to the back of the queue</li><li>Dequeue() will remove the top element from the queue</li></ul>",
      "image_link": "/assets/need-img.png"
    },
    {
      "type": "info",
      "title": "More on Queues",
      "text": "<ul><li>There are some very useful features of queues that are able to make certain problems much easier to solve. But just like stacks, there are some things to consider when using queues:</li><li>Removing an element from the middle of a queue is not possible</li><li>Adding too many objects or removing objects that are not present will break your code.</li><li>Avoid implementing your own queue class. Instead, import from the necessary library. It will save you time and unnecessary confusion just like with a stack</li></ul>",
      "image_link": "/assets/queue/queue-pop.png"
    },

    {
      "type": "quiz",
      "title": "Question #1",
      "text": "A queue can be best described as __ data structure.",
      "options": ["First-In-First-Out", "First-In-Last-Out", "Push-Out-Pop-In", "Pull-In-Push-Out"],
      "answer": "First-In-First-Out",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #2",
      "text": "If you wanted to add an item to the queue, you would use",
      "options": ["pop()", "push(item)", "enqueue(item)", "dequeue(item)"],
      "answer": "enqueue(item)",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #3",
      "text": "I can remove as many objects as I want from the queue with no consequences.",
      "options": ["True", "False"],
      "answer": "False",
      "image_link": "/assets/question-mark.gif"
    }
  ],

  "Tree": [
    {
      "type": "info",
      "title": "Binary Tree",
      "text": "A binary tree data structure is a special type of undirected graph with a root node at the top and each node has at most 2 children",
      "image_link": "/assets/binary-tree/binary-tree.png"
    },
    {
      "type": "info",
      "title": "Elements of a Binary Tree",
      "text": "<ul><li>Similar to graphs, a tree contains nodes and edges.</li><li>Innate hierarchy where the root is the parent and the two nodes it is connected to are its left and right children. </li><li>The principle applies down the tree for left and right all the way down to a leaf node</li><ul><li>Leaf node is a node without any children</li></ul></ul>",
      "image_link": "/assets/binary-tree/binary-tree-components.png"
    },
    {
      "type": "info",
      "title": "Problems to be solved with Binary Trees",
      "text": "<ul><li>Parsers</li><li>Decision making</li><li>Fundamental Components of more elaborate algorithms (topsort, dijkstra)</li></ul> ",
      "image_link": "/assets/binary-tree/decision-tree.png"
    },
    {
      "type": "info",
      "title": "Tree Traversals",
      "text":     "<ul><li>Breath-First Search</li><ul><li>Finds shortest path to a node since it traverses all nodes at a level before going to next level.</li></ul><li>Depth-First Search</li><ul><li>Results in deep trees and is more suitable for game or puzzle problems to explore paths </li></ul></ul>",
      "image_link": "/assets/binary-tree/tree-traversal.png"
    },

    {
      "type": "info",
      "title": "Problems that can be solved with BFS",
      "text": "<ul><li>Traverses a graph layer-wise thus exploring neighboring nodes before moving to next level</li><li>Finds shortest path to a node </li>",
      "image_link": "/assets/need-img.png"
    },

    {
      "type": "info",
      "title": "Problems that can be solved with DFS",
      "text": "<ul><li>Results in deep trees because the algorithm starts with root node and explores as far as possible down each branch before backtracking</li><li>Fundamental concept for topological sort such as scheduling classes considering prerequisites</li<li>Suitable for game or puzzle problems to explore paths </li></ul>",
      "image_link": "/assets/need-img.png"
    },
    
    {
      "type": "quiz",
      "title": "Question #1",
      "text": "Which of the following is false about binary trees?",
      "options": ["A child can also be a parent, in another context", "Can have multiple roots", "Recursive", "Fundamental data structure in CS"],
      "answer": "Can have multiple roots",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #2",
      "text": "BFS is used in all of the algorithms except",
      "options": ["Dijkstra’s shortest path, in another context", "Prim’s minimum spanning tree", "Artificial Neural Network", "Search Engine Crawlers"],
      "answer": "Artificial Neural Network",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #3",
      "text": "DFS is not used to",
      "options": ["Find the shortest path, in another context", "Check for cycles in a graph", "Topological sort", "Determine if 2 nodes are connected"],
      "answer": "Find the shortest path",
      "image_link": "/assets/question-mark.gif"
    }
  ],

  "Graph": [
    {
      "type": "info",
      "title": "Graph",
      "text": "<ul><li>A graph consists of a finite set of nodes and a finite set of edges which connect those nodes.</li><li>Graphs are used to solve many real-life problems by representing networks of just about anything!</li></ul>",
      "image_link": "/assets/graph/dij-road.png",
      "redirect_route": "#/undirected_graph_algorithms", 
      "credit_link": "https://www.quora.com/Does-Google-Maps-use-Dijkstras-algorithm-If-so-can-you-explain-how-they-discretize-the-world"
    },
    {
      "type": "info",
      "title": "Elements of a Graph",
      "text": "<ul><li><b>Nodes</b>: the fundamental units, also called <i>vertices</i><ul><li>Each node can simply be identified by a number of letter</li><li>Nodes can also contain objects with many fields</li></ul><li><b>Edges</b>: links which connect any two nodes in a graph</li></ul>",
      "image_link": "/assets/graph/graph-elements.png",
      "redirect_route": "#/undirected_graph_algorithms",
      "credit_link": "https://www.geeksforgeeks.org/applications-of-graph-data-structure/"
    },
    {
      "type": "info",
      "title": "Types of Graphs",
      "text": "<ul><li>Directed Graphs</li><ul><li>Each edge has a direction associated with it, represented by an <i>arrow</i></li><li>Can only move from one node to another if there is an arrow pointing from the source node to the target node</li></ul><li>Undirected Graphs</li><ul><li>Every edge has a double-sided arrow (↔), but the arrow heads are not shown</li><li>Can move from any node to any other node as long as they are connected by an edge</li></ul></ul>",
      "image_link": "/assets/graph/dir-undir-graph.png",
      "redirect_route": "#/directed_graph_algorithms",
      "credit_link": "https://towardsdatascience.com/graph-theory-basic-properties-955fe2f61914"
    },
    {
      "type": "info",
      "title": "Weighted Graphs",
      "text": "In weighted graphs, each edge has a numerical <i>weight</i> associated with it (typically positive integers). An edge’s weight is the cost of moving along that edge. <br/>Edge weights can represent physical distance, travel time, or energy required. <br/>Unweighted graphs can be thought of as a special case of weighted graphs in which all the weights are zero.",
      "image_link": "/assets/graph/weighted-graph-flights.gif",
      "redirect_route": "#/undirected_graph_algorithms",
      "credit_link": "http://jcsites.juniata.edu/faculty/rhodes/cs2java/graphs.htm"

    },
    {
      "type": "info",
      "title": "What Can Be Represented By Graphs?",
      "text": "<ul><li>Undirected graphs</li><ul><li>Street map (excluding one-ways)</li><li>Friendship network on Facebook</li><li>Wired connections between a circuit</li><li>Biological molecules like proteins and DNA</li></ul><li>Directed graphs</li><ul><li>The World Wide Web, where every hyperlink is an arrow from the current page to another page</li><li>Follower-based social media like Twitter and Facebook</li><li>Airline flights</li><li>Scheduling tasks</li></ul></ul>",
      "image_link": "/assets/graph/fb-graph.png",
      "redirect_route": "#/undirected_graph_algorithms",
      "credit_link": "https://medium.com/@verdi/working-with-graphs-f5cfc912e8bc"
    },

    {
      "type": "info",
      "title": "Undirected Weighted Graph Problems",
      "text": "<ul><li>Finding the shortest paths from one node to every other node</li><ul><li>Solution: <b>Dijkstra’s Shortest Path First</b> algorithm</li><li>Application: Mapping app that finds the fastest route to a destination</li></ul><li>Connecting all nodes with the smallest possible total edge weight, generating a <i>minimum spanning tree</i></li><ul><li>Solution: Prim's algorithm</li></ul><li>Application: a telecom company finding the least amount of cable needed to connect all houses</li></ul></ul>",
      "image_link": "/assets/graph/map-graph.png",
      "redirect_route": "#/undirected_graph_algorithms",
      "credit_link": "https://medium.com/@verdi/working-with-graphs-f5cfc912e8bc"
    },

    {
      "type": "info",
      "title": "Directed Graph Problems",
      "text": "Finding a linear sequence of all the nodes in a directed graph.<ul><li>Solution: Topological sort</li><li>Applications</li><ul><li>Determining a schedule of classes to complete a degree</li><li>Ordering the tasks in a project management flowchart</li><li>Operating systems task scheduling</li></ul></ul>",
      "image_link": "/assets/graph/sched-digraph.png",
      "redirect_route": "#/directed_graph_algorithms",
      "credit_link": ""
    },

    {
      "type": "quiz",
      "title": "Question #1",
      "text": "Which is an example of an undirected graph?",
      "options": ["The World Wide Web", "Followers on Instagram", "Network of flowing rivers", "Road network"],
      "answer": "Road Network",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #2",
      "text": "Which is an example of a directed graph?",
      "options": ["Facebook friend network", "Building a house", "Road network", "Airport network"],
      "answer": "Building a house",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #3",
      "text": "There are many applications of Dijkstra's algorithm such as distance between locations, IP Routing, and telephone networks.",
      "options": ["True","False"],
      "answer": "True",
      "image_link": "/assets/question-mark.gif"
    }
    ,
    {
      "type": "quiz",
      "title": "",
      "text": "Topological Sort can be used for",
      "options": ["Dependency resolution", "Scheduling classes", "Daily routine", "All of the above"],
      "answer": "All of the Above",
      "image_link": "/assets/question-mark.gif"
    }
  ],
  "Heap": [
    {
      "type": "info",
      "title": "Heap",
      "text": "<ul><li>A specialized tree-based data structure which satisfies heap property</li><ul><li>Min-heap: parent is always smaller value than children</li><ul><li>Root is minimum</li></ul></ul><ul><li>Max-heap: parent is always larger than children</li><ul><li>Root is max</li></ul></ul></ul>",
      "image_link": "/assets/heap/min-heap.png"
    },
    {
      "type": "info",
      "title": "Elements of a Heap",
      "text": "<ul><li>Similar to tree, however it is almost always a complete tree</li><ul><li>Complete tree: a binary tree such that every level (except possibly the last) is completely filled and all nodes are as far left as possible</li></ul></ul>",
      "image_link": "/assets/heap/max-heap.png"
    },
    {
      "type": "info",
      "title": "Why heaps?",
      "text": "<ul><li>They are extremely efficient at extracting the min/max value and re-organizing the tree to always maintain its property.</li><li>An maximally efficient implementation of priority queue</li><ul><li>Priority Queue: a queue with a priority associated with it</li><ul><li>Fundamental data structure to many algorithms such as dijkstra  </li></ul></ul></ul>",
      "image_link": "/assets/heap/heap-remove-root.gif"
    },
    {
      "type": "info",
      "title": "Problems that can be solved with a Heap",
      "text": "Any problem requiring a priority queue such as A* search, Dijkstra, sorting, etc.",
      "image_link": "/assets/need-img.png"
    },
    
    {
      "type": "quiz",
      "title": "Question #1",
      "text": "A heap is a special binary tree that can be used to",
      "options": ["Sort a list", "Act as a priority queue", "Quickly find largest/smallest element from a collection", "All of the above"],
      "answer": "All of the above",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #2",
      "text": "In a min-heap, the root node is the largest number.",
      "options": ["True", "False"],
      "answer": "False",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #3",
      "text": "A heap could be used by the operating system’s CPU scheduler to select the next process to execute.",
      "options": ["True","False"],
      "answer": "True",
      "image_link": "/assets/question-mark.gif"
    }
  ],

  "Insertion-Sort": [
    {
      "type": "info",
      "title": "Insertion Sort",
      "text": "The insertion sort one of many sorting algorithms that are used to order a list or array from lowest to highest number. It does so by comparing numbers side by side and swap locations in the list if the number is less than the number that is to its left. The algorithm will do this to every number in the list until it reaches the last number and places it in its correct spot. Think of gym class where everyone was lined up from tallest to shortest. You would compare yourself to the person next to you and swap places until you reached your appropriate spot. This is what Insertion sort accomplishes. ",
      "image_link": "/assets/sort/insertion-sort/is-line.jpg"
    },
    {
      "type": "info",
      "title": "Insertion Sort Steps",
      "text": "Each of these steps are done to each object by iterating over the entire array:<ol><li>Compare the current object you are evaluating to its predecessor</li><li>If the predecessor is greater than the current object, swap places</li><li>Continue to evaluate and swap places with previously evaluated objects until the current object is less than or equal to a previous object or reaches the beginning of the array</li><li>Move to the next unevaluated object in the array until complete</li></ol>",
      "image_link": "/assets/sort/insertion-sort/is-matrix.png"
    },
    {
      "type": "info",
      "title": "Insertion Sort Code",
      "text": "When looking at the algorithm, it uses only two loops to do the job:<ul><li>The first loop is used to iterate over the whole array and assign the current object to be checked</li><li>The second loop will swap objects if the object is not at the beginning of the array AND if the objects prior in the array are greater than the current object.</li></ul>",
      "image_link": "/assets/sort/insertion-sort/is-code.gif"
    },
    {
      "type": "info",
      "title": "Big O",
      "text": "Additional Useful Information for the Nerds:<br><ul><li>Best Case Time Complexity: O(n)</li><li>Worst Case Time Complexity O(n^2)</li><li>In-Place: Only requires a constant amount of memory space</li><li>When to Use: Insertion Sort works best with small lists of numbers or when the list is already somewhat sorted</li></ul>",
      "image_link": "/assets/sort/insertion-sort/runtime.png"
    },
    
    {
      "type": "quiz",
      "title": "Question #1",
      "text": "When using insertion sort, a number can make multiple swaps until it has reached its correct spot in the ordered array",
      "options": ["True","False"],
      "answer": "True",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #2",
      "text": "Best-case time complexity for insertion sort is ____, whereas worst-case time complexity for insertion sort is ____.",
      "options": ["O(logn), O(logn)", "O(n), O(n^3)", "O(n), O(n^2)","O(logn), O(n^2) "],
      "answer": "O(n), O(n^2)",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #3",
      "text": "Which best describes Insertion Sort?",
      "options": ["Most useful when the array size is large and very unordered","Memory space required is dynamic and is not constant", "Uses two loops in order to complete the job", "All of the above"],
      "answer": "Uses two loops in order to complete the job",
      "image_link": "/assets/question-mark.gif"
    }
  ],
  "Selection-Sort": [
    {
      "type": "info",
      "title": "Selection Sort",
      "text": "Selection sort is another way to sort an array in ascending order. By searching through the array over and over, it places the minimum value of searchable objects at the first of the array minimum index, raises that value, and repeats the process again. We’ll discuss in detail what all that really means, but for now consider this example. When you play cards, it is very common to order your cards for better clarity on what you have. You scan your hand and place the lowest value card all the way to the left. Once again, you scan the remaining cards and again place the lowest value card of that set to the left only this time to the right of the lowest value card from the last card placement. Keep doing this and you have a sorted playing hand. You’ve done this simple task by using selection sort.",
      "image_link": "/assets/sort/selection-sort/sel-sort-cards.jpeg"
    },
    {
      "type": "info",
      "title": "Selection Sort Steps",
      "text": "<ol><li>Using a minimum index tracking variable, set it to 0.</li><li>Search the array for the smallest element</li><li>Swap the smallest element with the element that has the minimum index tracking variable</li><li>Increment the minimum tracking variable by 1</li><li>Repeat this process until the list has been sorted</li></ol>",
      "image_link": "/assets/sort/selection-sort/sel-sort-steps.png"
    },
    
    {
      "type": "info",
      "title": "Selection Sort Code",
      "text": "The main functionality of selection sort relies heavily on the incrementing of the minimum index tracking variable. Each time we find the smallest value and place it at the minimum index tracking variable in the array, we want to shrink the search size by one each time so that we are not iterating over the same array size over and over. It swaps just like insertion sort, but the swap only happens once and that’s it. There’s no need to swap a value more than once because it’s already in the right spot whereas with insertion sort a number may need to swap multiple places before it reaches its final destination.",
      "image_link": "/assets/sort/selection-sort/sel-sort-code.png"
    },
    {
      "type": "info",
      "title": "The Nitty Gritty Behind Selection Sort",
      "text": "<ul><li>Best Case Time Complexity: O(n^2)</li><li>Worst Case Time Complexity: O(n^2)</li><li>In-Place: Only requires a constant amount of memory space</li><li>When to Use: Checking to make sure a list is already sorted. Also used when memory space is limited. This is because swapping is not done until the end which results in less temporary space usage.</li></ul>",
      "image_link": "/assets/sort/selection-sort/link-up.jpeg"
    },
    
    {
      "type": "quiz",
      "title": "Question #1",
      "text": "When should selection sort be used?",
      "options": ["Checking to make sure a list is already sorted.","When memory space is limited","Both", "None" ],
      "answer": "Both",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #2",
      "text": "Best-case time complexity for selection sort is ____, whereas worst-case time complexity for selection sort is ____.",
      "options": ["O(logn), O(n^2)", "O(n), O(n)", "O(n^2), O(n^2)","O(logn), O(n^2) "],
      "answer": "O(n^2), O(n^2)",
      "image_link": "/assets/question-mark.gif"
    },
    {
      "type": "quiz",
      "title": "Question #3",
      "text": "Selection sort only swaps a number once whereas insertion sort may swap a number many times.",
      "options": ["True","False"],
      "answer": "True",
      "image_link": "/assets/question-mark.gif"
    }
  ],

  "K-Means": [
    {
      "type": "info",
      "title": "K-Means Clustering",
      "text": "Clustering machine learning algorithms such as <strong>K-Means</strong> can be used for a wide variety of tasks, such as: <ul><li>Image segmentation</li><li>Spam email filtering</li><li>Anomaly detection</li><li>Market segmentation analysis</li><li>...and much more!</li></ul>K-Means is an example of an <strong>unsupervised learning algorithm,</strong> because it can take unlabeled data as input and produce informed, labeled decisions as output.",
      "image_link": "/assets/kmeans/kmeans-intro.png"
    },
    {
      "type": "info",
      "title": "The Main Idea",
      "text": "K-Means is one of the simplest and most commonly used unsupervised machine learning algorithms. It works by taking a collection of data and <strong>grouping similar points into a fixed number of clusters (K)</strong> that you can specify before running the algorithm. The image shown demonstrates K-Means running on a 2D dataset with a <strong>K parameter of 5 - that is, we want the algorithm to converge and find a group of 5 clusters.</strong> The algorithm converges when the centroid locations don’t change between iterations.",
      "image_link": "/assets/kmeans/kmeans-inprogress.gif"
    },
    {
      "type": "info",
      "title": "The K-Means Algorithm",
      "text": "You first define a <strong>target number K, which refers to the number of centroids you want to find in the dataset.</strong> A centroid is the imaginary or real location representing the center of the cluster. The algorithm will then initialize K cluster centroids at random, and alternate between two phases: <ol><li>assigning points to the closest cluster centroids by calculating the distance between them, and</li><li>updating the K centroids to the center, or mean, of the newly assigned group of points (hence the name K-Means).</li></ol>",
      "image_link": "/assets/kmeans/kmeans-pseudocode.png"
    },
    {
      "type": "info",
      "title": "Finding the Distance",
      "text": "There are many different distance metrics used to assign points to their closest cluster centroids. Examples include:<ul><li><strong>Euclidean distance (shown in orange)</strong>, also known as the Pythagorean Theorem, where you take the sum of the squares of the differences between points and then take the square root.</li><li><strong>Manhattan distance (shown in green),</strong> also known as city block distance, where you sum the absolute value of the difference between points, as if you were walking to your destination around the corner of a city block.</li></ul>",
      "image_link": "/assets/kmeans/kmeans-distance-intro.png"
    },
    {
      "type": "quiz",
      "title": "Question #1",
      "text": "What is the Euclidean distance between the two points shown?",
      "options": ["8", "5.83", "5", "3"],
      "answer": "5.83",
      "image_link": "/assets/kmeans/kmeans-quiz.png"
    }
  ],
  "Neural-Network": [
    {
      "type": "info",
      "title": "Neural Networks",
      "text": "Artificial neural networks are based on a collection of connected units or nodes called artificial neurons, which loosely model the neurons in a biological brain. Each connection, like the synapses in a biological brain, can transmit a signal to other neurons. An artificial neuron that receives a signal then processes it and can signal neurons connected to it. The 'signal' at a connection is a real number, and the output of each neuron is computed by some non-linear function of the sum of its inputs.<br><br>The structure of the most simple neural network has an input layer, an output layer, and a hidden layer.",
      "image_link": "/assets/neural-network/nn.png"
    },
    {
      "type": "info",
      "title": "Forward Propogation",
      "text": "The firing of individual neurons can be mathematically represented as the input values (x) multiplied by the weight values (w) that correspond to each connection, and then added to a bias value (b). ",
      "image_link": "/assets/neural-network/forward-prop.png"
    },
    
    {
      "type": "info",
      "title": "Training a Neural Network",
      "text": "Training a neural network can be broken down into three main stages:<ol><li>Forward propagation</li><li>Backpropagation</li><li>Parameter update </li></ol>",
      "image_link": "/assets/neural-network/nn-train.gif"
    },
    {
      "type": "info",
      "title": "Neural Network Basis",
      "text": "",
      "image_link": "/assets/neural-network/nn-axons.png"
    },
    {
      "type": "info",
      "title": "Forward Prop",
      "text": "",
      "image_link": "/assets/neural-network/forward-prop.png"
    }
    
  ]

}
